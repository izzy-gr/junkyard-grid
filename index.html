<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Junkyard Image Grid</title>
  <style>
    body {
      margin: 0;
      background: #000;
      font-family: sans-serif;
    }

    #mediaGrid {
      column-count: 3;
      column-gap: 0;
      max-width: none; /* full width */
      margin: 0 auto;
      padding: 0;
    }
    @media (max-width: 1200px) {
      #mediaGrid { column-count: 4; }
    }
    @media (max-width: 900px) {
      #mediaGrid { column-count: 3; }
    }
    @media (max-width: 600px) {
      #mediaGrid { column-count: 2; }
    }

    .mediaItem {
      break-inside: avoid;
      width: 100%;
      margin: 0;
      display: inline-block;
      overflow: hidden; /* so zoom never escapes */
      transition: filter 0.3s ease, opacity 0.3s ease;
      position: relative; /* for inside tooltip, if any */
    }
    .mediaItem img,
    .mediaItem video {
      width: 100%;
      height: auto;
      display: block;
      cursor: pointer;
      transform-origin: 50% 50%;
      transition: transform 0.3s ease;
    }

    /* only the selected item will scale on hover: */
    .mediaItem.selected img,
    .mediaItem.selected video {
      /* note: transform is set dynamically in JS */
    }

    /* tooltip style (date taken) — you can tweak this if you like */
    .mediaDateTooltip {
      position: absolute;
      background: #000000;
      color: #f4f2ea;
      padding: 12px;
      border-radius: 4px;
      max-width: 30vw;
      font-size: 16px;
      line-height: 1.4;
      opacity: 0;
      transition: opacity 0.3s ease-in;
      z-index: 10000;
      word-wrap: break-word;
      box-sizing: border-box;
      pointer-events: none;
    }
  </style>
</head>
<body>

  <div id="mediaGrid"></div>

  <!-- We’ll dynamically insert the tooltip container for “date taken” -->
  <div id="dateTooltip" class="mediaDateTooltip"></div>

  <script>
    // ───────────────────────────────────────────────────────────────
    // 1) Get a fresh Dropbox access token from our Netlify function
    // ───────────────────────────────────────────────────────────────
    async function getAccessToken() {
      const resp = await fetch('/.netlify/functions/get_dropbox_token');
      const { access_token } = await resp.json();
      return access_token;
    }

    // ───────────────────────────────────────────────────────────────
    // 2) Global variables
    // ───────────────────────────────────────────────────────────────
    const IMAGE_FOLDER_PATH = "/Junkyard/Images";
    const VIDEO_FOLDER_PATH = "/Junkyard/Videos";

    let mediaItems = [];           // Will hold all <div class="mediaItem"> nodes
    let currentFocusedIndex = null; // null = nothing is selected

    const dateTooltip = document.getElementById("dateTooltip");

    // This helper will add the .selected class to exactly one <.mediaItem>
    function selectItem(idx) {
      mediaItems.forEach((wrapper, i) => {
        if (i === idx) {
          wrapper.classList.add("selected");
          wrapper.style.filter  = "";
          wrapper.style.opacity = "1";
        } else {
          wrapper.classList.remove("selected");
          wrapper.style.filter  = "blur(3px) grayscale(100%) brightness(70%)";
          wrapper.style.opacity = "0.7";
        }
      });
      currentFocusedIndex = idx;
    }

    // Reset everything to “no item selected”
    function resetFilters() {
      mediaItems.forEach((w) => {
        w.classList.remove("selected");
        w.style.filter  = "";
        w.style.opacity = "";
      });
      currentFocusedIndex = null;
      dateTooltip.style.opacity = "0"; // hide the tooltip if it’s visible
    }

    // ───────────────────────────────────────────────────────────────
    // 3) Main “fetch & render” function
    // ───────────────────────────────────────────────────────────────
    async function fetchDropboxMedia() {
      const ACCESS_TOKEN = await getAccessToken();
      const mediaGrid = document.getElementById("mediaGrid");

      // Clear out any old items:
      mediaGrid.innerHTML = "";
      mediaItems = [];           // reset our “global” array
      currentFocusedIndex = null;

      // 3.1) Load & shuffle images
      const imgRes  = await fetch("https://api.dropboxapi.com/2/files/list_folder", {
        method: "POST",
        headers: {
          Authorization: "Bearer " + ACCESS_TOKEN,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ path: IMAGE_FOLDER_PATH })
      });
      let imageEntries = (await imgRes.json()).entries
        .filter(e => e[".tag"] === "file");
      for (let i = imageEntries.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [imageEntries[i], imageEntries[j]] = [imageEntries[j], imageEntries[i]];
      }
      imageEntries = imageEntries.slice(0, 11); // pick 11 random images

      // 3.2) Load & shuffle videos
      const vidRes  = await fetch("https://api.dropboxapi.com/2/files/list_folder", {
        method: "POST",
        headers: {
          Authorization: "Bearer " + ACCESS_TOKEN,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ path: VIDEO_FOLDER_PATH })
      });
      let videoEntries = (await vidRes.json()).entries
        .filter(e => e[".tag"] === "file");
      for (let i = videoEntries.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [videoEntries[i], videoEntries[j]] = [videoEntries[j], videoEntries[i]];
      }
      const [videoEntry] = videoEntries; // pick exactly 1 random video

      // 3.3) Mix them together, then shuffle
      const allEntries = [...imageEntries, videoEntry];
      for (let i = allEntries.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allEntries[i], allEntries[j]] = [allEntries[j], allEntries[i]];
      }

      // 3.4) For each entry, fetch its temporary link & render:
      for (const entry of allEntries) {
        const linkRes = await fetch("https://api.dropboxapi.com/2/files/get_temporary_link", {
          method: "POST",
          headers: {
            Authorization: "Bearer " + ACCESS_TOKEN,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ path: entry.path_lower })
        });
        const { link: fileUrl } = await linkRes.json();

        // Create an <img> or <video> based on file extension:
        const isVideo = /\.(mp4|mov)$/i.test(entry.name);
        const mediaElement = document.createElement(isVideo ? "video" : "img");
        mediaElement.src = fileUrl;
        mediaElement.alt = entry.name;
        if (isVideo) {
          mediaElement.autoplay    = true;
          mediaElement.loop        = true;
          mediaElement.muted       = true;
          mediaElement.playsInline = true;
          mediaElement.controls    = false;
        }

        // Wrap it in a <div class="mediaItem">
        const wrapper = document.createElement("div");
        wrapper.className = "mediaItem";
        wrapper.appendChild(mediaElement);
        mediaGrid.appendChild(wrapper);
        mediaItems.push(wrapper);

        // Grab the inner <img> or <video> node so we can set transform‐origin on hover:
        const mediaNode = wrapper.querySelector("img,video");

        // 3.4.1) “Zoom” on hover, but only if this wrapper is .selected
        wrapper.addEventListener("mousemove", e => {
          if (!wrapper.classList.contains("selected")) return;
          const rect = wrapper.getBoundingClientRect();
          const x = ((e.clientX - rect.left ) / rect.width ) * 100;
          const y = ((e.clientY - rect.top  ) / rect.height) * 100;
          mediaNode.style.transformOrigin = `${x}% ${y}%`;
        });
        wrapper.addEventListener("mouseleave", () => {
          if (!wrapper.classList.contains("selected")) return;
          mediaNode.style.transformOrigin = "50% 50%";
        });

        // 3.4.2) On click: if nothing is selected, spotlight this one.
        //           If “something is already selected,” let the outside-click listener handle resetting.
        mediaElement.addEventListener("click", e => {
          if (currentFocusedIndex !== null) {
            // something’s already spotlit → do nothing here,
            // the “click outside” handler will fire instead,
            // which resets everything.
            return;
          }
          e.stopPropagation();
          selectItem(mediaItems.indexOf(wrapper));
        });
      }
    } // end fetchDropboxMedia()


    // ───────────────────────────────────────────────────────────────
    // 4) “Click-outside” listener (anywhere on the page resets if something is selected)
    // ───────────────────────────────────────────────────────────────
    document.body.addEventListener("click", e => {
      // If no item is selected, bail out immediately:
      if (currentFocusedIndex === null) return;

      // If the click happened inside the currently selected wrapper, do nothing:
      const selectedWrapper = mediaItems[currentFocusedIndex];
      if (selectedWrapper.contains(e.target)) {
        return;
      }

      // Otherwise, clear the spotlight:
      resetFilters();
    });


    // ───────────────────────────────────────────────────────────────
    // 5) Arrow-key navigation (←/→) + Esc to reset
    // ───────────────────────────────────────────────────────────────
    document.addEventListener("keydown", e => {
      if (e.key === "Escape") {
        return resetFilters();
      }
      if (currentFocusedIndex !== null) {
        if (e.key === "ArrowRight" && currentFocusedIndex < mediaItems.length - 1) {
          selectItem(currentFocusedIndex + 1);
        }
        if (e.key === "ArrowLeft"  && currentFocusedIndex > 0) {
          selectItem(currentFocusedIndex - 1);
        }
      }
    });


    // ───────────────────────────────────────────────────────────────
    // 6) Kick it all off
    // ───────────────────────────────────────────────────────────────
    fetchDropboxMedia();
  </script>
</body>
</html>
