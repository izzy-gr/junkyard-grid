<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Junkyard Image Grid</title>
  <style>
    body { margin: 0; background: #000; font-family: sans-serif; }
    #mediaGrid {
      column-count: 3;
      column-gap: 0;
      max-width: none;        /* optional—let it span full width */
      margin: 0 auto;
      padding: 0;
    }

    /* tweak at smaller breakpoints if you like */
    @media (max-width: 1200px) {
      #mediaGrid { column-count: 4; }
    }
    @media (max-width: 900px) {
      #mediaGrid { column-count: 3; }
    }
    @media (max-width: 600px) {
      #mediaGrid { column-count: 2; }
    }

    .mediaItem {
      break-inside: avoid;
      width: 100%;
      margin: 0;
      display: inline-block;
      transition: filter 0.3s ease, opacity 0.3s ease;
      overflow: hidden;       /* ensure overflow hidden for zoom/blur */
    }
    .mediaItem img,
    .mediaItem video {
      width: 100%;
      height: auto;
      display: block;
      cursor: pointer;
    }

    /* zoom the selected on hover */
    .mediaItem.selected img,
    .mediaItem.selected video {
      transition: transform 0.3s ease;
    }
    /* (You already removed the transform-origin here, because we're doing it in JS.) */
    /* .mediaItem.selected:hover img,
       .mediaItem.selected:hover video {
         transform: scale(2);
       } */

    /* New: styling for the “date taken” tooltip */
    .mediaDateTooltip {
      position: absolute;
      background: #000000;
      color: #f4f2ea;
      padding: 12px;
      border-radius: 4px;
      max-width: 30vw;
      font-size: 16px;
      line-height: 1.4;
      opacity: 0;
      transition: opacity 0.3s ease-in;
      z-index: 10000;
      word-wrap: break-word;
      box-sizing: border-box;
    }
  </style>
</head>
<body>
  <div id="mediaGrid"></div>

  <!-- (Your lightbox HTML can stay here, but we’re no longer using it in JS.) -->
  <div id="lightboxOverlay">
    <div id="lightboxClose">&times;</div>
    <div id="lightboxContent"></div>
  </div>

  <script>
    /**************************************************************************
     * 1) Helper: format an ISO‐string into “Mon D, YYYY”. 
     **************************************************************************/
    function formatDate(isoString) {
      const d = new Date(isoString);
      return d.toLocaleDateString("en-US", {
        year: "numeric",
        month: "short",
        day: "numeric"
      });
    }

    /**************************************************************************
     * 2) Spotlight / blur helper (unchanged). 
     *    We keep track of which thumbnail is spotlit so that clicking again
     *    will reset everything.
     **************************************************************************/
    let currentFocusedIndex = null;
    function selectItem(idx) {
      document.querySelectorAll(".mediaItem").forEach((wrapper, i) => {
        if (i === idx) {
          wrapper.classList.add("selected");
          wrapper.style.filter  = "";
          wrapper.style.opacity = "1";
        } else {
          wrapper.classList.remove("selected");
          wrapper.style.filter  = "blur(3px) grayscale(100%) brightness(70%)";
          wrapper.style.opacity = "0.7";
        }
      });
      currentFocusedIndex = idx;
    }

    function resetFilters() {
      document.querySelectorAll(".mediaItem").forEach((w) => {
        w.style.filter  = "";
        w.style.opacity = "";
        w.classList.remove("selected");
      });
      currentFocusedIndex = null;

      // Remove any existing date tooltip
      const oldTip = document.querySelector(".mediaDateTooltip");
      if (oldTip) oldTip.remove();
    }

    /**************************************************************************
     * 3) Fetch a fresh Dropbox access token from our Netlify function.
     **************************************************************************/
    async function getAccessToken() {
      const resp = await fetch('/.netlify/functions/get_dropbox_token');
      const { access_token } = await resp.json();
      return access_token;
    }

    /**************************************************************************
     * 4) Main function: list_folder → pick 9 images + 1 video → render.
     **************************************************************************/
    (async function fetchDropboxMedia() {
      const ACCESS_TOKEN = await getAccessToken();
      const IMAGE_FOLDER_PATH = "/Junkyard/Images";
      const VIDEO_FOLDER_PATH = "/Junkyard/Videos";
      const mediaGrid = document.getElementById("mediaGrid");
      mediaGrid.innerHTML = "";
      let mediaItems = [];

      // 4a) List all images:
      const imgRes = await fetch(
        "https://api.dropboxapi.com/2/files/list_folder",
        {
          method: "POST",
          headers: {
            Authorization: "Bearer " + ACCESS_TOKEN,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ path: IMAGE_FOLDER_PATH })
        }
      );
      const imgData = await imgRes.json();
      let imageEntries = imgData.entries.filter(e => e[".tag"] === "file");

      // 4b) Shuffle images, pick first 9:
      for (let i = imageEntries.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [imageEntries[i], imageEntries[j]] = [imageEntries[j], imageEntries[i]];
      }
      imageEntries = imageEntries.slice(0, 9);

      // 4c) List all videos:
      const vidRes = await fetch(
        "https://api.dropboxapi.com/2/files/list_folder",
        {
          method: "POST",
          headers: {
            Authorization: "Bearer " + ACCESS_TOKEN,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ path: VIDEO_FOLDER_PATH })
        }
      );
      const vidData = await vidRes.json();
      let videoEntries = vidData.entries.filter(e => e[".tag"] === "file");

      // 4d) Shuffle videos, pick the first one:
      for (let i = videoEntries.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [videoEntries[i], videoEntries[j]] = [videoEntries[j], videoEntries[i]];
      }
      const [ videoEntry ] = videoEntries;

      // 4e) Combine the 9 images + 1 video into a single array, then reshuffle:
      const allEntries = [...imageEntries, videoEntry];
      for (let i = allEntries.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allEntries[i], allEntries[j]] = [allEntries[j], allEntries[i]];
      }

      // 4f) Render each of the 10 chosen entries:
      for (let idx = 0; idx < allEntries.length; idx++) {
        const entry = allEntries[idx];

        // Fetch a temporary link:
        const linkRes = await fetch(
          "https://api.dropboxapi.com/2/files/get_temporary_link",
          {
            method: "POST",
            headers: {
              Authorization: "Bearer " + ACCESS_TOKEN,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ path: entry.path_lower })
          }
        );
        const linkData = await linkRes.json();
        const fileUrl = linkData.link;

        // Create <img> or <video> depending on the extension:
        const isVideo = /\.(mp4|mov)$/i.test(entry.name);
        const mediaElement = document.createElement(isVideo ? "video" : "img");
        mediaElement.src = fileUrl;
        mediaElement.alt = entry.name;
        if (isVideo) {
          mediaElement.autoplay    = true;
          mediaElement.loop        = true;
          mediaElement.muted       = true;
          mediaElement.playsInline = true;
          mediaElement.controls    = false;
        }

        // Wrap & append:
        const wrapper = document.createElement("div");
        wrapper.className = "mediaItem";
        mediaGrid.appendChild(wrapper);
        wrapper.appendChild(mediaElement);
        mediaItems.push(wrapper);

        // ── NEW: fetch metadata to pull “time_taken” ──
        const metaRes = await fetch(
          "https://api.dropboxapi.com/2/files/get_metadata",
          {
            method: "POST",
            headers: {
              Authorization: "Bearer " + ACCESS_TOKEN,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              path: entry.path_lower,
              include_media_info: true,
              include_deleted: false
            })
          }
        );
        const metaData = await metaRes.json();

        // If EXIF “time_taken” exists, use that; otherwise fallback to "Date… idk"
        let dateTaken = "Date\u2026 idk";
        if (
          metaData.media_info &&
          metaData.media_info.metadata &&
          metaData.media_info.metadata.time_taken
        ) {
          dateTaken = metaData.media_info.metadata.time_taken;
        }
        wrapper.dataset.dateTaken = dateTaken;
        // ────────────────────────────────────────────────────────────────

        // Fetch the <img> or <video> node inside this wrapper:
        const mediaNode = wrapper.querySelector("img,video");

        // 4g) On mousemove inside a selected wrapper → adjust transform‐origin so
        //     that the zoom (transform: scale(2)) follows the mouse.
        wrapper.addEventListener("mousemove", e => {
          if (!wrapper.classList.contains("selected")) return;
          const rect = wrapper.getBoundingClientRect();
          const x = ((e.clientX - rect.left) / rect.width)  * 100;
          const y = ((e.clientY - rect.top ) / rect.height) * 100;
          mediaNode.style.transformOrigin = `${x}% ${y}%`;
        });

        // 4h) On mouseleave, reset transform‐origin to center:
        wrapper.addEventListener("mouseleave", () => {
          if (!wrapper.classList.contains("selected")) return;
          mediaNode.style.transformOrigin = "50% 50%";
        });

        // 4i) Click handler: spotlight + show the date tooltip:
        mediaElement.addEventListener("click", e => {
          e.stopPropagation();

          // If something is already selected, just let the outer click‐reset run:
          if (currentFocusedIndex !== null) {
            return;
          }

          // Otherwise, spotlight this one:
          selectItem(idx);

          // Decide what to show:
          const raw = wrapper.dataset.dateTaken;
          const displayText =
            raw === "Date\u2026 idk"
              ? raw
              : formatDate(raw);

          // Show the little tooltip near the wrapper:
          showDateTooltip(wrapper, displayText);
        });

      } // ← end for(each entry)
    })(); // ← end fetchDropboxMedia()

    /**************************************************************************
     * 5) If you click anywhere outside a .mediaItem, we reset everything:
     **************************************************************************/
    document.body.addEventListener("click", e => {
      if (!e.target.closest(".mediaItem")) {
        resetFilters();
      }
    });

    /**************************************************************************
     * 6) Pressing “Escape” also resets:
     **************************************************************************/
    document.addEventListener("keydown", e => {
      if (e.key === "Escape") {
        resetFilters();
      }
    });

    /**************************************************************************
     * 7) showDateTooltip(wrapper, text) creates (or re‐positions) a .mediaDateTooltip
     *    DIV so that it floats just above the selected thumbnail (or below if
     *    there’s no room above). We also fade it in via CSS.
     **************************************************************************/
    function showDateTooltip(wrapper, formattedDate) {
      // 7a) Remove any old tooltip first:
      const oldTip = document.querySelector(".mediaDateTooltip");
      if (oldTip) oldTip.remove();

      // 7b) Create a new <div class="mediaDateTooltip">
      const tip = document.createElement("div");
      tip.className = "mediaDateTooltip";
      tip.textContent = formattedDate;
      document.body.appendChild(tip);

      // 7c) Measure sizes so we can position above/below:
      const rectTip  = tip.getBoundingClientRect();
      const rectWrap = wrapper.getBoundingClientRect();

      // Try to place above by default:
      let top = rectWrap.top - rectTip.height - 8;
      // If that would run off‐screen, place below instead:
      if (top < 8) {
        top = rectWrap.bottom + 8;
      }

      // Center horizontally (clamped to viewport edges):
      let left = rectWrap.left + (rectWrap.width - rectTip.width)/2;
      left = Math.max(8, Math.min(left, window.innerWidth - rectTip.width - 8));

      tip.style.top  = `${top}px`;
      tip.style.left = `${left}px`;

      // 7d) Finally fade it in:
      requestAnimationFrame(() => {
        tip.style.opacity = "1";
      });
    }
  </script>
</body>
</html>
